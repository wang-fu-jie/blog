---
title:       自制操作系统 - 硬盘调度算法和数据结构
subtitle:    "硬盘调度算法和数据结构"
description: ""
excerpt:     ""
date:        2024-02-23T19:47:08+08:00
author:      "王富杰"
image:       "https://c.pxhere.com/photos/6c/da/city_light_trail_light_night_long_exposure-173683.jpg!d"
published:   false
tags:
    - 操作系统
slug:        "os-disk-algorithm"
categories:  [ "操作系统" ]
---

## 一、磁盘电梯调度算法
由于磁盘性能的主要瓶颈在磁盘的寻道时间，也就是磁头臂的移动时间，所以要尽可能避免磁头臂的移动。电梯算法的作用是让磁头的综合移动距离最小，从而改善磁盘访问时间。

假设我们的磁盘有7个磁道，由内往外分别是1~7。当前磁头臂在2磁道，来了一个需求需要读取6磁道，又来了一个需求读取4磁道，如果按照先来先服务，那磁头臂应该由2摆动到6再摆动到4，这样磁头臂的移动距离就比较大，电梯算法解决的就是这个问题，让磁头臂从2摆动到4再摆动到6。


### 1.1 电梯算法的实现
我们这里介绍下电梯算法的实现思路，即把磁盘读写请求添加到一个链表，每次插入请求进行一次插入排序。然后从链表表找到合适的请求方法。

## 二、哈希表
哈希表：散列表，以关键字和数据 (key - value) 的形式直接进行访问的数据结构。可以通过拉链法来解决哈希冲突的问题。
```cpp

```


## 三、高速缓冲
一般来说，性能不同的两个系统之间应该有一个缓冲区；文件系统以块为单位访问磁盘，块一般是 2的n次方 个扇区。其中 4K 比较常见；这里我们使用 1K，也就是 2 个扇区作为一块。高速缓冲将块存储在哈希表中，以降低对磁盘的访问频率，提高性能。

高速缓冲需要用到内存区域，我们调整使用8M~12M的内存区域作为高速缓冲。也就是磁盘读出的扇区会存储到这个位置，这样对扇区的多次读写就可以在内存中进行，最后只需要一次刷回磁盘。

接下来看告诉缓存的实现，这里内核的内存需要改为16M，因为告诉缓存需要使用4M，另外4M预留给虚拟磁盘。
```cpp
#define BLOCK_SIZE 1024                       // 块大小
#define SECTOR_SIZE 512                       // 扇区大小
#define BLOCK_SECS (BLOCK_SIZE / SECTOR_SIZE) // 一块占 2 个扇区

typedef struct buffer_t
{
    char *data;        // 数据区
    dev_t dev;         // 设备号
    idx_t block;       // 块号
    int count;         // 引用计数
    list_node_t hnode; // 哈希表拉链节点
    list_node_t rnode; // 缓冲节点
    lock_t lock;       // 锁
    bool dirty;        // 是否与磁盘不一致
    bool valid;        // 是否有效
} buffer_t;

```

