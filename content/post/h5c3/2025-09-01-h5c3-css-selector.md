---
title:       HTML & CSS - CSS选择器
subtitle:    "CSS选择器"
description: "CSS选择器多种多样，大类包括基础选择器、伪类选择器、伪元素选择器和组合选择器。当同一个元素被多个选择器选中且属性冲突时，浏览器会通过比较重要性、特殊性和源次序最终确实胜出的属性。本文还讲述了CSS属性的计算流程和继承，最终确定浏览器使用哪个属性值进行渲染。"
excerpt:     "CSS选择器多种多样，大类包括基础选择器、伪类选择器、伪元素选择器和组合选择器。当同一个元素被多个选择器选中且属性冲突时，浏览器会通过比较重要性、特殊性和源次序最终确实胜出的属性。本文还讲述了CSS属性的计算流程和继承，最终确定浏览器使用哪个属性值进行渲染。"
date:        2025-09-01T17:16:21+08:00
author:      "王富杰"
image:       "https://c.pxhere.com/photos/25/21/woman_photo_taking_picture_photography_person_female_camera-756610.jpg!d"
published:   true
tags:
    - CSS
slug:        "h5c3-css-selector"
categories:  [ "PYTHON" ]
---

## 一、基础选择器
上篇文章中我们已经介绍了三种基础选择器，分别为元素选择器、id选择器、类选择器。这里先进行回顾一下。使用元素选择器后，页面上所有的该元素都会应用这个CSS样式。使用id选择器，只有设置了id的元素就应用这个样式。使用类选择器，设置了class属性值的为知道名称的元素都会应用这个选择器的样式
```css
p{
    color: yellow;
} 
#debug{
    font-size: 2em;
}
.blue{
    color: blue;
}
```
如上所示，页面所有p元素颜色都会为yellow。id为debug的元素字体为2em。class属性为blue的元素颜色都会为蓝色。接下来我们介绍更多的选择器。


### 1.1、通配符选择器
通配符选择器用 * 表示，用来选中所有元素。
```css
*{
    color: green
}
```
使用通配符选择器，页面所有的元素都会应用这个样式。

### 1.2、属性选择器
属性选择器根据属性名和属性值来选择元素，并应用指定的样式。属性选择器使用 [] 表示，如：
```css
[title]{
    color: green
}
[title="标题"]{
    color: green
}
```
使用属性选择器时，如果不写属性值，如[title]，那么所有拥有这个属性的元素都会应该该样式。当写了属性值，如[title="标题"]，只有具有该属性且属性值也匹配的元素才会应用这个样式。注意：这里属性值的引号不可以也可以正确渲染，但是如果有特殊符号必须加上引号。

属性选择器还有更多的用法，例如[attr*=value] 当属性值包含value就会应该这个css规则，更多的用法可以查询mdn手册。

## 二、伪类选择器
伪类选择器是选中某些元素的某种状态，我们这里先介绍四种伪类选择器。分别为：
* link: 超链接未被访问过的状态，未访问过的链接会应用这个css规则
* visited: 超链接访问过的状态， 访问过的链接会应用这个css规则
* hover: 表示鼠标悬停状态，当鼠标悬在元素上时，应用这个css规则
* active: 激活状态，当鼠标按下还没有松开时就应用这个css规则

这四个伪类选择器多用于 a 元素。
```css
a:hover{
    color: red
}
```
示例如上：当鼠标悬停在a链接上时，字体会变成红色。最后当元素同时有这四个伪类选择器的css规则时，必须是lvha这个顺序。如果不按这个顺序，就可能出现某个css规则不生效。如把 :hover 写在 :link 或 :visited 之前。当鼠标悬停时，虽然元素匹配 :hover，但它同时也匹配 :link 或 :visited，而 CSS 采用“后写规则覆盖前写规则”的原则，这样 :hover 样式看不到效果


## 三、伪元素选择器
伪元素选择器我们先学习两个，一个是before，一个是after。伪元素选择器使用两个冒号。
```css
strong::before{
    content: "#"
}

strong::after{
    content: "#",
    color: red
}
```
如上所示，就是伪元素选择器的css规则，这个规则的只有是在strong元素的前面和后边分别加一个 # 号。并且后面的字体颜色是红色。可以认为这个before和after是 strong 元素的子元素。

## 四、组合选择器
前面讲过的选择器都是可以组合使用的，也就是组合选择器。前边的示例其实我们已经使用了组合选择器，如 strong::before 就是元素选择器和伪元素选择器的组合。组合选择器也分为多种：

### 4.1、交集选择器
两个或多个选择器的交集，用法就是把两个选择器直接写在一起。
```css
p.abc[title="段落"]{
    color: red
}

.abc.def{
    color: green
}
```
如上所示，交集选择器把多个选择器写在一起。例：p.abc[title="段落"]就是选择设置了 class="abc" 且属性title="段落"的p元素应该这个规则。 .abc.def选择的是设置了class="abc def"的选择，多个选择器之间没有空格。

### 4.2、并集选择器
并集选择器是合并相同的样式，使用逗号分隔多个选择器。即当多个选择器使用同样的样式时，就可以进行合并
```css
h1,
strong,
.abc {
    color: red
}
```
如上，这个css规则的作用是把所有的 h1 、strong 以及 class="abc"的元素都设置为红色。当然这里的选择器也可以不换行书写。


### 4.3、后代选择器
后代选择器的作用是在一个选择器的后代元素中找到另一个选择器所指的元素。语法是使用空格隔开多个选择器。
```css
main p{
    color: red
}
```
如上这个css规则是选择 main元素中的 p元素设置颜色为红色，即main元素的后代元素中的p元素。

### 4.4、子元素选择器
子元素选择器是在一个选择器的子元素中找到另一个选择器所指的元素，这里注意和后代选择器的区别，子元素选择器的语法是使用>隔开选择器
```css
main>p{
    color: red
}
```
子元素选择器一般用的比较少，大多使用后代选择器。

### 4.5、兄弟选择器
兄弟选择器包含两种，一种是相邻兄弟选择器使用 + 连接，一种是通用兄弟选择器使用 ~ 连接。
```css
[href="baidu"]+a{
    color: red
}
[href="baidu"]~a{
    color: red
}
```
我们看下这两个css规则，第一个是只会选择属性href="baidu"的元素的相邻的一个兄弟元素a。但是第二个会选择所有的兄弟元素a。 需要注意一点的是，兄弟选择器只会选择它下面的兄弟，如果第一个选择器被选择的元素它上边的兄弟是不会被选择的。


## 五、层叠
有些元素浏览器会内置默认的样式，我们也可以自己来写样式。例如假设浏览器默认设置了color，我们写的css也写了color。针对这种同一个样式属性多次应用到同一个元素的情况称之为声明冲突。 当然我们自己写的样式之间也会有冲突。这些冲突的样式最后只有一个样式能胜出，解决声明冲突的过程就叫重叠，也叫权重计算。

解决冲突是浏览器负责解决的，解决冲突的过程分为以下三步：

### 5.1、比较重要性
重要性由高到低分别是 !important -> 普通样式 -> 浏览器默认样式。普通样式指的是我们书写的样式。
```css
a{
    color: red !important
}
```
如上，声明了一个!important样式，它的重要性最高，但是一般不建议使用，使用了!important过多代码的可读性和可维护性都会很差。

我们可以利用重要性来重置样式表，例如不同的浏览器的默认样式可能不一样，我们的网页在不同浏览器上想渲染一样的效果就不能依赖默认样式。因此在项目开始时一般会写一些基础样式来覆盖浏览器的默认样式。重置样式表一般不需要自己书写，网上有一些现成的，如reset.css、normalize.css。

### 5.2、比较特殊性
如果冲突重要性是一样的，就需要进一步比较特殊性。选择器选择的范围越窄就越特殊。浏览器会通过选择器计算出一个四位数 0000 ，这个四位数越大，特殊性越高。
* 千位： 内联样式记1, 否则记0
* 百位： 等于选择器中所有id选择器的数量
* 十位： 等于选择器中所有类选择器、属性选择器和伪类选择器的数量和
* 个位： 等于选择器中所有元素原则器和伪元素选择器的数量和

注意：这里的四位数不是普通意义上的四位数，例如，如果个位超过了9会继续向上累加。最大好像能到255，当然我们一般也不会有这么长的选择器。
```css
a {
    color: red,
    background-color: bule
}

a.selector{
    color: green
}
```
如上所示，这两个原则上的特殊性分别为（0, 0, 0, 1）和（0, 0, 1, 1）。 如果一个a元素同时设置了class="selector"，那它的颜色会被设置为绿色，红色就会被淘汰，因为绿色重要性更高。这里比较重要性先比较千位，如果千位大，那剩余的百位、十位、个位就不用比较了，依次类推。但是background-color依然都为蓝色，因为background-color这个样式并不存在冲突。

### 5.3、比较源次序
当两个选择重要性也一样的时候，就需要比较源次序，即源代码的书写顺序，代码书写靠后的胜出。
```css
div .sellector{
    color: green
}

.nav a{
    color: red
}
```
如上这两个css规则的重要性都是 （0, 0, 1, 1）， 当一个元素同时满足这两个选择器，就会应用红色，因此它书写更靠后。


## 六、继承
继承指的是子元素会继承父元素的部分css属性。通常来说和文字相关的属性都能被继承。当需要知道一个属性是否会被继承可以查mdn手册。比如字体颜色是可以继承的。
```html
<style>
    div{
        color: blue;
        background-color: red;
       }
</style>


<div>
    <p>Lorem, ipsum dolor.</p>
    <h1>Quisquam, perspiciatis aliquam?</h1>
    <p>Autem, nulla assumenda.</p>
</div>
```
如上所示，p元素和h1元素的颜色都是蓝色，背景色都是红色。通过浏览器可以看到如下：
![图片加载失败](/post_images/h5c3/{{< filename >}}/6-01.png)
可以看到p元素继承了div的字体颜色。但是背景颜色是灰色的，说明背景颜色不能被继承。那为什么页面显示背景是红色的呢。那是因为div的背景颜色为红色，但是p元素默认的背景颜色是透明的，因此显示出了div的背景色。可以通过浏览器的计算样式来查看p元素的背景色为rgb(0,0,0,0)。最后一个为透明度，默认是透明。当设置不为0时，就可以看到p元素的背景色不再为红色了。

### 6.1、强制继承
如果元素已经有了某个属性值，那它就不会继承父元素的属性。但是如果又想使用父元素的属性，就可以强制继承。如：
```css
a{
    color: inherit
}
```
如上所示，这样a元素就会强制继承父元素的颜色属性。


## 七、CSS属性值的计算过程
浏览器渲染一个元素的前提是，该元素的所有CSS属性都必须要有值。一个元素所有属性从没有值到有值的过程就是CSS属性值的计算过程。这个计算涉及四个步骤
* 确定声明值：样式表中没有冲突的声明，直接作为CSS属性值
* 层叠：样式表中有冲突的声明，使用层叠规则确定CSS属性值
* 继承： 前两步结束后，依然没有值的可继承属性，则继承父元素的值
  * inherit：强制继承，本来不会继承的属性也可以强制继承
  * initial: 属性的初始值，如果想直接使用初始值，可以在设置属性时使用这个单词 
* 使用默认值：做完前三步，依然没有值的属性则使用默认值。

页面渲染时会先从html元素开始渲染计算属性值，依然往下按照以上四个步骤进行计算并渲染。

最后看一个场景，我们再第六章的示例代码中加一个a元素，显示时a元素并没有变红。因为浏览器对a元素有默认样式，因此第一步确定声明值就有了color属性，因此到第三步就不会继承了。但是可以手动写css规则来强制继承，注意：如果强制继承的规则出现属性冲突，那它也是会进程层叠的，层叠如果强制继承的规则优先级更低，那这个强制继承的规则不会生效。