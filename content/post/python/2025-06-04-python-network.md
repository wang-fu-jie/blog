---
title:        Python基础 - 网络编程基础
subtitle:    "网络编程基础"
description: "在进行网络编程前，需要先了解一下网络通信的基础知识，本文将从硬件到应用系统的介绍计算机是如何通信的。包含OSI网络模型，网络的具体通信过程，以及网络模型每层都做了哪些事情。"
excerpt:     "在进行网络编程前，需要先了解一下网络通信的基础知识，本文将从硬件到应用系统的介绍计算机是如何通信的。包含OSI网络模型，网络的具体通信过程，以及网络模型每层都做了哪些事情。"
date:        2025-06-04T09:51:09+08:00
author:      "王富杰"
image:       "https://c.pxhere.com/photos/72/36/bicycle_bench_bike_sea_man-142.jpg!d"
published:   true
tags:
    - Python
    - Python基础
slug:        "python-network"
categories:  [ "PYTHON" ]
---

## 一、网络模型
在网络编程中，开发的应用系统架构模式一般有两种，CS架构和BS架构。CS指的是客户端-服务器架构，BS指的是浏览器-服务器架构，它们都需要通过网络进行通信。

### 1.1、物理连接介质
如下图所示， 逐个介绍一个各种设备的作用：
![图片加载失败](/post_images/python/{{< filename >}}/1.1-01.png)
* 路由器：提供WiFi功能和少量的网线插口，给无线设备和有线设备提供网络。
* 交换机：当需要网线插口的设备比较多时，路由器不足以提供，就需要交换机，交换机需要接到路由器上。
* 光猫：又称调制解调器，负责拨号上网、分配内网IP（如192.168.1.100）、提供Wi-Fi信号，但是光猫提供的wifi一般比较差。路由器需要接入光猫
* 电信设备箱：光猫需要接入电信的设备箱，可能一个社区或一个机构使用一个设备箱，多个光猫接入同一个设备箱
* 运行商机房：设备箱需要接入到运行商的机房，三大运行商之间会相互连接，连接使用的是光缆

这里需要说明：路由器和交换机是可以相互连接的，例如路由器可以再接一个路由器，交换机也可以接出多个交换机。

### 1.2、OSI七层模型
网路有了传输介质后，还需要解决诸多问题，如多系统、不同介质(wifi、网线)、多软件，要保证不同介质信号可以相互转换，不同软件的通信可以正确发生到目标。因此ISO组织就制定了网络通信的参考模型，即OSI七层模型。
* 物理层：解决信号转换的问题，负责光信号(光纤)、电信号(网线)、电磁波(WiFi)与数字信号(010111)的转换
* 数据链路层：提供了mac地址，mac地址全世界唯一，例如手机常见的入网许可证就是去申请mac地址，由IEEE组织分配
* 网络层：提供了IP地址，公网IP全世界唯一，IP由IANA组织分配，还有内网IP，是局域网唯一。
* 传输层：解决了用什么方式发数据的问题，提供了UDP和TCP两种协议。TCP和UDP提供了端口的概念，端口解决多个软件之间通信的问题
* 会话层：建立、维护、管理通信会话，准备收发数据
* 表示层：数据格式转换、加解密、压缩等、描述传输文件的类型	
* 应用层：提供网络服务给应用程序（如浏览器），如HTTTP、FTP都属于应用层的协议

OSI七层模型不是实际协议的直接实现，而是一个逻辑参考框架，它帮助我们理解和设计网络系统的各个部分。比较流行的说法还有四层模型和五层模型。五层模型是把 会话层、表示层、应用层统一称为应用层。四层模型是把物理层和数据链路层统一称为网络接口层。实际使用的协议（如 IP、TCP、UDP、DNS、HTTP）都基于四层模型设计。

### 1.3、封包、解包与抓包
这里以TCP/IP协议为例，协议规定了数据组织的格式，基本都是头部+数据组成。打包过程就是给数据添加头部，解包就是拿掉头部获取数据。这里基于五层模型来看下每层都会封装哪些头部。我们这里先进行抓包，抓包可以通过wirshark或者tcpdump工具。
![图片加载失败](/post_images/python/{{< filename >}}/1.3-01.png)
如上所示：我们看其中一个数据包。点开即可查看每层封装了哪些头部信息，例如TCP层的头部封装了端口。这样没经过一层都会添加到该层的头部，发送到目标后，目标再逐层进行解包去除头部。

## 二、网络通信
我们基于五层模型来介绍了计算机的通信过程。

### 2.1、数据帧
物理层：  010101010101  称一组数据为一个bit流

数据链路层： 以太网协议Ethernet，称一组数据为一个数据帧。 它的头部包含源端和目的端的mac地址和上一层的协议类型，例如ipv4，一共占14个字节，它还会在数据的几位做一个帧校验标记，占4字节，保证数据的正确传输，但是抓包工具看不到它。在数据帧中还有前导码和帧其实界定符，他们是固定的魔数。数据部分最大时1500字节，超过则会进行切片。
![图片加载失败](/post_images/python/{{< filename >}}/2.1-01.png)

### 2.2、广播
有了物理层和数据链路层后，其实就已经可以进行通信了。以太网协议的工作方式是广播。在同一个广播域的计算机就可以通过广播通信了，例如连接到同一个交换机的设备就可以构成一个广播域。在一个广播域中，一个设备发出的数据所有设备都会接收到，他们解包后发现mac目的不是自己会丢掉，只有目的mac的那台设备会接收数据。

在一个广播域内如果设备过多，而且同时多个设备都在发数据，那这个广播域内的信息量是巨大的，这就会引发广播风暴，因此全世界的电脑接入一个广播域是不可行的，需要把计算机划分到不同的广播域里面，也就是广播分域。但是数据链路层就做不到了，需要网络层。

网络层将计算机划分到多个广播域，但是位于跨广播域的计算机也需要通信，这时候就需要给每个广播域分一个网关，网关有两个地址，一个局域网的地址，一个连接公网的地址。这样源设备将数据广播给自己的网关，网关通过公网发送到目标设备的网格，目标设备的网关再广播给目标设备。

网络层使用的协议是IP协议，称一组数据为一个数据包。数据包的头部包含源设备的IP和目标设备的IP。

### 2.3、NAT技术
目前常用的IP是第四版，即ipv4，由32位组成。因此ipv4的总数量是2**32，大约是43亿个。但是全球需要接入网络的设备远远不止43亿，因此出现了两种解决方案：第一种是剥离一部分ip重复使用，这就是NAT技术(网络地址转换)。这部分IP给内网使用，当内网的计算机对外通信时，发送给内网网关，网关做一次网络地址转换，转换为公网IP发送给目标设备。

内网网段有三段，10.0.0.0 ~ 10.255.255.255 有1600多万个ip。第二个网段是 172.16.0.0  ~ 172.31.255.255，有约104万个ip。第三个网段是 192.168.0.0 ~ 192.168.255.255， 共计65536个ip。还有一个特殊的网段 127.0.0.0 ~ 127.255.255.255。127开头的网段是保留地址，127的数据包不会离开本机。当然还有一些机构保留的ip，这里我们把这些包括剩余的ip都认为是公网地址。

第二种方案就是ipv6，它有128位，因此ipv6足够多。但是目前ipv4还是主流。

### 2.4、子网掩码
子网掩码也是由32位组成。作用是 将一个 IP 地址划分为“网络地址”和“主机地址”两部分，以便在一个大的网络中划分出多个较小的子网，并进行路由控制。一个合法的ip地址是由ip和子网掩码组成。例 192.168.3.88/255.255.255.0，在linux上的写法是  192.168.3.88/24。通俗的说，子网掩码就是来划分广播域的。

在linux中24代表前面24位是1，后8位是0，正好对应255.255.255.0。如下
```python
255.255.255.0   =》 11111111.11111111.11111111.00000000
192.168.3.88    =》 11000000.10101000.00000011.01011000  （网络位相同就是同一个网段）
                    [          网络位        ]  [主机位]
192.168.3.0     =》 11000000.10101000.00000011.00000000   网络号 第一个ip地址
192.168.3.1     =》 11000000.10101000.00000011.00000001   第一个可用ip
...... 
192.168.3.254   =》 11000000.10101000.00000011.11111110  最后一个可用ip
192.168.3.255   =》 11000000.10101000.00000011.11111111   广播地址，最好一个ip地址
```
ip地址和子网掩码进行按位与即可获取网络号，如果网络号一致则在同一网段。


### 2.5、ARP协议
在将多台计算机连接到一个交换机后，并配上局域网的ip地址，此时他们就可以通信了。另外目前使用的多为二层交换机，即交换机可以解析到网络链路层可以看到mac地址但是看不到ip地址。因此两台计算机只知道ip地址不能进行直接通信，要么就广播给每台发一份，但是广播没有私密性，因此ARP协议就诞生了。

ARP协议又称地址解析协议，工作在第二层和第三层之间，它作用是将ip解析成mac地址。ARP协议也是通过广播解析mac地址的。假设192.168.2.1想和192.168.2.2通信，它会先发送一条ARP广播，内容是"谁是192.168.2.2，请告诉192.168.2.1"。 192.168.2.2接收到消息后，会把自己mac地址发送给192.168.2.1，192.168.2.1会把这个mac地址和192.168.2.2这个ip的对应关系缓存起来，也就是ARP缓存表。ARP缓存表有过期时间，如果过期了会再次广播，多次广播未得到会有，ARP缓存表就会删除这一项。

交换机也有一个mac地址表，只要连接上它的计算机发生过一次通信，交换机就会记录这台计算机连接的接口。然后两台计算机就可以基于mac地址进行通信了。可以在windows体验一下ARP广播。windows支持以下命令
```
arp -a      # 查看arp缓存表
arp -d *    # 清空arp缓存表
```
![图片加载失败](/post_images/python/{{< filename >}}/2.5-01.png)
通过以上抓住可以感受到ARP广播的流程。通过分析包内容，也就知道网段的最后一个ip是广播地址。

### 2.6、SNAT与DNAT
前面我们知道，两台计算机进行通信必须知道对方的ip地址。如果在同一个子网内，就通过ARP协议获取对方的mac地址，把数据通过交换机发送。但是如果不在一个子网内，还是需要通过ARP协议拿到网关的mac地址。注意只有跨局域网才会用到网关，一般家庭网络是路由器充当网关的作用。

接下来我们说一下跨局域网通信的过程，局域网内机器发生数据给公网服务器，首先它会把数据发送给路由器，路由器通过SNAT(源地址地址)把ip转为网关的公网地址再把数据发生给目标服务器。目标服务器发送回来的数据也是先回到路由器的公网地址。那路由器是如何知道把这条消息转发给局域网内的源机器呢。这就是传输层解决的问题，源机器发生数据到路由器后，路由器将消息的ip的端口映射为一个新的ip和端口，这样回来的消息再通过这个端口转换回去。这就是反向SNAT。

还有一个DNAT(目标地址转换)，它的作用是内网机器提供服务，响应公网发过来的请求。路由器将内网机器提供的服务映射到网关公网ip的一个端口，就可以对外提供服务了。需要注意的是，跨局域网通信是不需要mac地址的，mac地址的作用只是为了找到网关。

## 三、传输层
通过网络层，我们已经可以通过ip找到唯一一个计算机，但是消息发送给这台计算机的哪个程序，还需要用到传输层提供的端口。传输层常用的协议有tcp和udp。在传输层一组数据被称为一个数据段，传输层会加入tcp/udp头部， 头部包含端口和数据段的序列号。因为应用层传输的数据比较大，传输层就需要把数据拆为一段一段的，每段都有一个序列号。tcp没发出一段，目的端都需要回应有没有收到，没收到就进行补发，这也是tcp可靠的原因，但是udp只管发，不管是否收到。

### 3.1、TCP协议
TCP在进行发数据之前，要先探测网络是否通常，创建连接，这就是三次握手。
![图片加载失败](/post_images/python/{{< filename >}}/3.1-01.png)
如图所示，为建立通信的三次握手过程。这里也可以抓包体验一下三次握手的过程，图中的seq和ack是随机序列号和确认序列号，SEQ：标识发送的数据从哪个字节开始，解决乱序问题，ACK：确认已接收的数据，解决丢包问题。三次握手时seq是随机生成的。

TCP断开连接时需要四次挥手。挥手过程如下所示：我们这里不进行详述具体过程。具体细节可自行查询相关资料或进行抓包体验。
![图片加载失败](/post_images/python/{{< filename >}}/3.2-01.png)

## 四、应用层
接下来就可以写应用层了，应用层的协议比较多，如http、ftp等。我们写的代码进行通信需要经常这么多层，都需要封装头部，应用层以下肯定不需要自己封装的，这样就太麻烦了，于是就出现了socket，socket把应用层以下都封装好了。

## 五、dhcp与dns
经过以上网络模型的介绍，已经可以进行网站的网络编程了。但是仍然存在一个点，例如我们连上wifi后并没有配置ip那它如何通信的呢。这就是dhcp协议的存在，dhcp会自动分配IP地址。如果手动配置也可以，配置网关一定和确定路由器的网关ip是多少，否则可能无法访问公网。

再说一下DNS，现在可以通过IP进行通信，但是我们不可能记住那么多网站的ip，例如百度。因此需要有一个功能将www.baidu.com转换成IP，这就是DNS。首先操作系统本地有一个IP到域名的映射，例如linux的/etc/hosts。可以在这个文件配置域名对应的IP。 但是都在本地配置是不合理的，因为网站的域名和IP都有发生变化，因此就有了DNS。

DNS是一个服务器，当我们通过域名访问网站时，会先给DNS服务发一个请求，DNS会返回域名的IP，接下来就可以基于IP进行通信了。